using System.Collections;
using System.Collections.Generic;
using TMPro;
using System.Linq;
using UnityEngine;

public class TextSizeController : MonoBehaviour
{
    [SerializeField] private TMP_Text[] _texts;

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
        {
            //foreach (var item in _texts)
            //    item.text = words[Random.Range(0, words.Length)];

            StartCoroutine(TextSizeChange());
        }
    }

    private IEnumerator TextSizeChange()
    {
        for (int i = 0; i <_texts.Length; i++)
            _texts[i].fontSizeMax = 100;

        yield return new WaitWhile(delegate 
        {
            return _texts.All(item => item.fontSize == _texts[0].fontSize); 
        });
        yield return new WaitUntil(delegate
        {
            float minTextSize = float.MaxValue;

            foreach (var item in _texts)
                if (item.fontSize < minTextSize)
                    minTextSize = item.fontSize;

            foreach (var item in _texts)
                item.fontSizeMax = minTextSize;

            return _texts.All(item => item.fontSize == minTextSize);
        });
    }

//    private void Awake()
//    {
//        _texts[0].text = "";
//        words = text.Split(new char[] { '\n', '\r' }, System.StringSplitOptions.RemoveEmptyEntries);
//        for (int i = 0; i < words.Length; i++)
//        {
//            words[i] = $"{i}{i}{i}";
//        }
//    }

//    int i = 0;
//    string[] words;

//    string text = @"ШАБЛОНЫ
//- Есть лишние пустые строки
//- В конце/начале методов не надо ставить пустых строк.
//- Перед методами/конструкторами должна быть пустая строка
//- Сокращения в именах не используем
//- код идущий сплошным полотном тяжело читать, разбивайте его на логические блоки с помощью пустых строк
//- Между публичными и приватными членами должна быть пустая строка
//- Приватные члены идут в начале, затем защищенные и затем публичные
//- Перед циклами, условиями и после, лучше оставлять пустые строки(если это не начало/конец метода)
//- Если используете фигурные скобки в одном месте if else, то надо использовать везде
//- Поля/свойства не инициализируем в классе, для этого есть конструктор.
//- В коде не должно быть магических чисел, все используемые значения должны быть в переменных с говорящим названием
//- while (true) - у цикла обязательно должно быть условие окончания
//- чем for не устроил? Все ровно костыли используете в виде id++
//- Во-первых, поля не должны быть публичными.Во-вторых смотрите лекцию о проблеме передачи ссылок на массив.Логика работы с коллекцией должна быть инкапсулирована в классе.
//- у методов нет модификаторов доступа
//- у метода Main нет модификатора доступа
//- меню реализуется через свич
//- В свиче лучше использовать числа, а не строки.Работа со строками очень грамоздкая
//- По циклу НЕ понятно, когда он закончится.
//- Все используемые числа поместить в переменные с понятным смыслом.
//- GetKey - название не соответствует выполняемой задаче + смешано в одном методе несколько ответственностей
//- булевы переменные должны называться актуально с точки зрения английской грамматики. Допускается использование вспомогательных глаголов (Пример: canOpen, IsOpen, Open)
//- зачем при подсчете суммы и произведения бегать по всему массиву, если тебе нужен только один столбец и одна строка конкретные?
//- enough - не достаточно конкретное название.Из названия переменной должно быть ясно для чего она используется
//- в конце названия переменных, отвечающих за хранение количества чего-то, лучше дописывать Count
//- произведите декомпозицию. Сейчас все слеплено в одном цикле. В одном куске кода 3 разные ответственности, это не хорошо.Необходимо разнести логику по разным частям
//- скидывай код программы целиком с методами и неймспейсом
//- Нужно скидывать весь код программы с демонстрацией работы методов
//- Код скидываем ссылкой на гит репозиторий или на pastebin";
}
